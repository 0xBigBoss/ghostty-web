diff --git a/.gitignore b/.gitignore
index e451b171a..89c623d8b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,3 +23,4 @@ glad.zip
 /ghostty.qcow2
 
 vgcore.*
+node_modules/
diff --git a/include/ghostty/vt.h b/include/ghostty/vt.h
index 4f8fef88e..ca9fb1d4d 100644
--- a/include/ghostty/vt.h
+++ b/include/ghostty/vt.h
@@ -28,6 +28,7 @@
  * @section groups_sec API Reference
  *
  * The API is organized into the following groups:
+ * - @ref terminal "Terminal Emulator" - Complete terminal emulator with VT parsing
  * - @ref key "Key Encoding" - Encode key events into terminal sequences
  * - @ref osc "OSC Parser" - Parse OSC (Operating System Command) sequences
  * - @ref sgr "SGR Parser" - Parse SGR (Select Graphic Rendition) sequences
@@ -74,6 +75,7 @@ extern "C" {
 
 #include <ghostty/vt/result.h>
 #include <ghostty/vt/allocator.h>
+#include <ghostty/vt/terminal.h>
 #include <ghostty/vt/osc.h>
 #include <ghostty/vt/sgr.h>
 #include <ghostty/vt/key.h>
diff --git a/include/ghostty/vt/terminal.h b/include/ghostty/vt/terminal.h
new file mode 100644
index 000000000..35abd534f
--- /dev/null
+++ b/include/ghostty/vt/terminal.h
@@ -0,0 +1,416 @@
+/**
+ * @file terminal.h
+ *
+ * Terminal emulator and render state APIs.
+ */
+
+#ifndef GHOSTTY_VT_TERMINAL_H
+#define GHOSTTY_VT_TERMINAL_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup terminal Terminal Emulator
+ *
+ * Terminal emulator lifecycle, render state access, and scrollback APIs.
+ *
+ * @{
+ */
+
+/**
+ * Opaque handle to a terminal instance.
+ *
+ * @ingroup terminal
+ */
+typedef struct GhosttyTerminal *GhosttyTerminal;
+
+/**
+ * Terminal configuration overrides.
+ *
+ * All colors are packed as 0xRRGGBB. Use 0 to indicate "no override".
+ *
+ * @ingroup terminal
+ */
+typedef struct {
+  uint32_t scrollback_limit;
+  uint32_t fg_color;
+  uint32_t bg_color;
+  uint32_t cursor_color;
+  uint32_t palette[16];
+} GhosttyTerminalConfig;
+
+/**
+ * Rendered terminal cell.
+ *
+ * @ingroup terminal
+ */
+typedef struct {
+  uint32_t codepoint;
+  uint8_t fg_r;
+  uint8_t fg_g;
+  uint8_t fg_b;
+  uint8_t bg_r;
+  uint8_t bg_g;
+  uint8_t bg_b;
+  uint8_t flags;
+  uint8_t width;
+  uint16_t hyperlink_id;
+  uint8_t grapheme_len;
+  uint8_t _padding;
+} GhosttyTerminalCell;
+
+/** Cell style flags. @ingroup terminal */
+#define GHOSTTY_CELL_FLAG_BOLD (1u << 0)
+#define GHOSTTY_CELL_FLAG_ITALIC (1u << 1)
+#define GHOSTTY_CELL_FLAG_UNDERLINE (1u << 2)
+#define GHOSTTY_CELL_FLAG_STRIKETHROUGH (1u << 3)
+#define GHOSTTY_CELL_FLAG_INVERSE (1u << 4)
+#define GHOSTTY_CELL_FLAG_INVISIBLE (1u << 5)
+#define GHOSTTY_CELL_FLAG_BLINK (1u << 6)
+#define GHOSTTY_CELL_FLAG_FAINT (1u << 7)
+
+/** Render state dirty result. @ingroup terminal */
+typedef enum {
+  GHOSTTY_RENDER_STATE_DIRTY_NONE = 0,
+  GHOSTTY_RENDER_STATE_DIRTY_PARTIAL = 1,
+  GHOSTTY_RENDER_STATE_DIRTY_FULL = 2,
+} GhosttyRenderStateDirty;
+
+/** Render state dirty reason bitmask. @ingroup terminal */
+#define GHOSTTY_RENDER_DIRTY_SCREEN_SWITCH (1u << 0)
+#define GHOSTTY_RENDER_DIRTY_TERMINAL_PALETTE (1u << 1)
+#define GHOSTTY_RENDER_DIRTY_TERMINAL_REVERSE (1u << 2)
+#define GHOSTTY_RENDER_DIRTY_TERMINAL_CLEAR (1u << 3)
+#define GHOSTTY_RENDER_DIRTY_TERMINAL_PREEDIT (1u << 4)
+#define GHOSTTY_RENDER_DIRTY_SCREEN_SELECTION (1u << 5)
+#define GHOSTTY_RENDER_DIRTY_SCREEN_HYPERLINK (1u << 6)
+#define GHOSTTY_RENDER_DIRTY_SIZE_CHANGED (1u << 7)
+#define GHOSTTY_RENDER_DIRTY_VIEWPORT_PIN (1u << 8)
+
+/**
+ * Create a new terminal instance.
+ *
+ * @param cols Terminal columns
+ * @param rows Terminal rows
+ * @return Terminal handle or NULL on failure
+ *
+ * @ingroup terminal
+ */
+GhosttyTerminal ghostty_terminal_new(uint16_t cols, uint16_t rows);
+
+/**
+ * Create a new terminal instance with configuration overrides.
+ *
+ * @param cols Terminal columns
+ * @param rows Terminal rows
+ * @param config Optional configuration overrides, or NULL
+ * @return Terminal handle or NULL on failure
+ *
+ * @ingroup terminal
+ */
+GhosttyTerminal ghostty_terminal_new_with_config(
+    uint16_t cols,
+    uint16_t rows,
+    const GhosttyTerminalConfig *config);
+
+/**
+ * Destroy a terminal instance.
+ *
+ * @param terminal Terminal handle (NULL is ignored)
+ *
+ * @ingroup terminal
+ */
+void ghostty_terminal_free(GhosttyTerminal terminal);
+
+/**
+ * Resize the terminal.
+ *
+ * @param terminal Terminal handle
+ * @param cols New columns
+ * @param rows New rows
+ *
+ * @ingroup terminal
+ */
+void ghostty_terminal_resize(GhosttyTerminal terminal, uint16_t cols, uint16_t rows);
+
+/**
+ * Write input bytes into the terminal parser.
+ *
+ * @param terminal Terminal handle
+ * @param input Input bytes
+ * @param len Length of input
+ *
+ * @ingroup terminal
+ */
+void ghostty_terminal_write(GhosttyTerminal terminal, const uint8_t *input, size_t len);
+
+/**
+ * Update render state from terminal state.
+ *
+ * @param terminal Terminal handle
+ * @return Dirty state (0=none, 1=partial, 2=full)
+ *
+ * @ingroup terminal
+ */
+uint32_t ghostty_render_state_update(GhosttyTerminal terminal);
+
+/**
+ * Get the dirty reason bitmask for the most recent render_state_update.
+ *
+ * @param terminal Terminal handle
+ * @return Bitmask of GHOSTTY_RENDER_DIRTY_* values
+ *
+ * @ingroup terminal
+ */
+uint32_t ghostty_render_state_get_dirty_reasons(GhosttyTerminal terminal);
+
+/**
+ * Get render state columns.
+ *
+ * @param terminal Terminal handle
+ * @return Columns
+ *
+ * @ingroup terminal
+ */
+uint16_t ghostty_render_state_get_cols(GhosttyTerminal terminal);
+
+/**
+ * Get render state rows.
+ *
+ * @param terminal Terminal handle
+ * @return Rows
+ *
+ * @ingroup terminal
+ */
+uint16_t ghostty_render_state_get_rows(GhosttyTerminal terminal);
+
+/**
+ * Get cursor X coordinate in viewport.
+ *
+ * @param terminal Terminal handle
+ * @return Cursor X
+ *
+ * @ingroup terminal
+ */
+uint16_t ghostty_render_state_get_cursor_x(GhosttyTerminal terminal);
+
+/**
+ * Get cursor Y coordinate in viewport.
+ *
+ * @param terminal Terminal handle
+ * @return Cursor Y
+ *
+ * @ingroup terminal
+ */
+uint16_t ghostty_render_state_get_cursor_y(GhosttyTerminal terminal);
+
+/**
+ * Get cursor visibility in viewport.
+ *
+ * @param terminal Terminal handle
+ * @return True if visible
+ *
+ * @ingroup terminal
+ */
+bool ghostty_render_state_get_cursor_visible(GhosttyTerminal terminal);
+
+/**
+ * Get background color (0xRRGGBB) for current render state.
+ *
+ * @param terminal Terminal handle
+ * @return Packed RGB color
+ *
+ * @ingroup terminal
+ */
+uint32_t ghostty_render_state_get_bg_color(GhosttyTerminal terminal);
+
+/**
+ * Get foreground color (0xRRGGBB) for current render state.
+ *
+ * @param terminal Terminal handle
+ * @return Packed RGB color
+ *
+ * @ingroup terminal
+ */
+uint32_t ghostty_render_state_get_fg_color(GhosttyTerminal terminal);
+
+/**
+ * Check if a row is dirty after render_state_update.
+ *
+ * @param terminal Terminal handle
+ * @param row Row index
+ * @return True if dirty
+ *
+ * @ingroup terminal
+ */
+bool ghostty_render_state_is_row_dirty(GhosttyTerminal terminal, uint16_t row);
+
+/**
+ * Mark render state as clean (clears dirty flags for all rows).
+ *
+ * @param terminal Terminal handle
+ *
+ * @ingroup terminal
+ */
+void ghostty_render_state_mark_clean(GhosttyTerminal terminal);
+
+/**
+ * Get the rendered viewport cells.
+ *
+ * @param terminal Terminal handle
+ * @param out_cells Output cell array
+ * @param max_cells Capacity of out_cells (rows * cols)
+ * @return Number of cells written, or -1 on error
+ *
+ * @ingroup terminal
+ */
+ptrdiff_t ghostty_render_state_get_viewport(
+    GhosttyTerminal terminal,
+    GhosttyTerminalCell *out_cells,
+    size_t max_cells);
+
+/**
+ * Get the grapheme at a viewport cell position.
+ *
+ * @param terminal Terminal handle
+ * @param row Viewport row
+ * @param col Viewport column
+ * @param out_codepoints Output codepoints buffer
+ * @param max_len Capacity of out_codepoints
+ * @return Number of codepoints written, or -1 on error
+ *
+ * @ingroup terminal
+ */
+ptrdiff_t ghostty_render_state_get_grapheme(
+    GhosttyTerminal terminal,
+    uint16_t row,
+    uint16_t col,
+    uint32_t *out_codepoints,
+    size_t max_len);
+
+/**
+ * Check if the alternate screen is active.
+ *
+ * @param terminal Terminal handle
+ * @return True if alternate screen is active
+ *
+ * @ingroup terminal
+ */
+bool ghostty_terminal_is_alternate_screen(GhosttyTerminal terminal);
+
+/**
+ * Check if any mouse tracking mode is enabled.
+ *
+ * @param terminal Terminal handle
+ * @return True if mouse tracking is enabled
+ *
+ * @ingroup terminal
+ */
+bool ghostty_terminal_has_mouse_tracking(GhosttyTerminal terminal);
+
+/**
+ * Get a terminal mode value.
+ *
+ * @param terminal Terminal handle
+ * @param mode_value Mode number
+ * @param is_ansi True for ANSI modes, false for DEC private modes
+ * @return True if the mode is enabled
+ *
+ * @ingroup terminal
+ */
+bool ghostty_terminal_get_mode(GhosttyTerminal terminal, uint16_t mode_value, bool is_ansi);
+
+/**
+ * Get scrollback length (number of lines above the active screen).
+ *
+ * @param terminal Terminal handle
+ * @return Scrollback length
+ *
+ * @ingroup terminal
+ */
+uint32_t ghostty_terminal_get_scrollback_length(GhosttyTerminal terminal);
+
+/**
+ * Read a scrollback line into an output buffer.
+ *
+ * @param terminal Terminal handle
+ * @param offset Scrollback line offset (0 = oldest)
+ * @param out_cells Output cell array (length >= cols)
+ * @param cols Number of columns to copy
+ * @return Number of cells written, or -1 on error
+ *
+ * @ingroup terminal
+ */
+ptrdiff_t ghostty_terminal_get_scrollback_line(
+    GhosttyTerminal terminal,
+    uint32_t offset,
+    GhosttyTerminalCell *out_cells,
+    uint16_t cols);
+
+/**
+ * Get a grapheme in the scrollback buffer.
+ *
+ * @param terminal Terminal handle
+ * @param offset Scrollback line offset (0 = oldest)
+ * @param col Column index
+ * @param out_codepoints Output codepoints buffer
+ * @param max_len Capacity of out_codepoints
+ * @return Number of codepoints written, or -1 on error
+ *
+ * @ingroup terminal
+ */
+ptrdiff_t ghostty_terminal_get_scrollback_grapheme(
+    GhosttyTerminal terminal,
+    uint32_t offset,
+    uint16_t col,
+    uint32_t *out_codepoints,
+    size_t max_len);
+
+/**
+ * Check if an active screen row is wrapped.
+ *
+ * @param terminal Terminal handle
+ * @param row Row index
+ * @return True if the row is wrapped
+ *
+ * @ingroup terminal
+ */
+bool ghostty_terminal_is_row_wrapped(GhosttyTerminal terminal, uint16_t row);
+
+/**
+ * Check if a terminal response is available.
+ *
+ * @param terminal Terminal handle
+ * @return True if a response is available
+ *
+ * @ingroup terminal
+ */
+bool ghostty_terminal_has_response(GhosttyTerminal terminal);
+
+/**
+ * Read a terminal response into an output buffer.
+ *
+ * @param terminal Terminal handle
+ * @param out_buffer Output buffer
+ * @param max_len Capacity of out_buffer
+ * @return Number of bytes written, or -1 on error
+ *
+ * @ingroup terminal
+ */
+ptrdiff_t ghostty_terminal_read_response(
+    GhosttyTerminal terminal,
+    uint8_t *out_buffer,
+    size_t max_len);
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GHOSTTY_VT_TERMINAL_H */
diff --git a/src/build_config.zig b/src/build_config.zig
index c19f7372b..2c679435f 100644
--- a/src/build_config.zig
+++ b/src/build_config.zig
@@ -7,8 +7,8 @@ const builtin = @import("builtin");
 const options = @import("build_options");
 const assert = std.debug.assert;
 const apprt = @import("apprt.zig");
-const font = @import("font/main.zig");
-const rendererpkg = @import("renderer.zig");
+const font_backend_pkg = @import("font/backend.zig");
+const renderer_backend_pkg = @import("renderer/backend.zig");
 const BuildConfig = @import("build/Config.zig");
 
 pub const ReleaseChannel = BuildConfig.ReleaseChannel;
@@ -39,8 +39,8 @@ pub const exe_entrypoint = config.exe_entrypoint;
 pub const flatpak = options.flatpak;
 pub const snap = options.snap;
 pub const app_runtime: apprt.Runtime = config.app_runtime;
-pub const font_backend: font.Backend = config.font_backend;
-pub const renderer: rendererpkg.Backend = config.renderer;
+pub const font_backend: font_backend_pkg.Backend = config.font_backend;
+pub const renderer: renderer_backend_pkg.Backend = config.renderer;
 pub const i18n: bool = config.i18n;
 
 /// The bundle ID for the app. This is used in many places and is currently
@@ -82,8 +82,8 @@ pub const Artifact = enum {
 
     pub fn detect() Artifact {
         if (builtin.target.cpu.arch.isWasm()) {
-            assert(builtin.output_mode == .Obj);
-            assert(builtin.link_mode == .Static);
+            assert(builtin.output_mode == .Obj or builtin.output_mode == .Exe);
+            assert(builtin.link_mode == .static);
             return .wasm_module;
         }
 
diff --git a/src/lib_vt.zig b/src/lib_vt.zig
index 03a883e20..aae897154 100644
--- a/src/lib_vt.zig
+++ b/src/lib_vt.zig
@@ -140,6 +140,42 @@ comptime {
         @export(&c.sgr_unknown_partial, .{ .name = "ghostty_sgr_unknown_partial" });
         @export(&c.sgr_attribute_tag, .{ .name = "ghostty_sgr_attribute_tag" });
         @export(&c.sgr_attribute_value, .{ .name = "ghostty_sgr_attribute_value" });
+        // Terminal lifecycle
+        @export(&c.terminal_new, .{ .name = "ghostty_terminal_new" });
+        @export(&c.terminal_new_with_config, .{ .name = "ghostty_terminal_new_with_config" });
+        @export(&c.terminal_free, .{ .name = "ghostty_terminal_free" });
+        @export(&c.terminal_resize, .{ .name = "ghostty_terminal_resize" });
+        @export(&c.terminal_write, .{ .name = "ghostty_terminal_write" });
+
+        // RenderState API - high-performance rendering
+        @export(&c.render_state_update, .{ .name = "ghostty_render_state_update" });
+        @export(&c.render_state_get_dirty_reasons, .{ .name = "ghostty_render_state_get_dirty_reasons" });
+        @export(&c.render_state_get_cols, .{ .name = "ghostty_render_state_get_cols" });
+        @export(&c.render_state_get_rows, .{ .name = "ghostty_render_state_get_rows" });
+        @export(&c.render_state_get_cursor_x, .{ .name = "ghostty_render_state_get_cursor_x" });
+        @export(&c.render_state_get_cursor_y, .{ .name = "ghostty_render_state_get_cursor_y" });
+        @export(&c.render_state_get_cursor_visible, .{ .name = "ghostty_render_state_get_cursor_visible" });
+        @export(&c.render_state_get_bg_color, .{ .name = "ghostty_render_state_get_bg_color" });
+        @export(&c.render_state_get_fg_color, .{ .name = "ghostty_render_state_get_fg_color" });
+        @export(&c.render_state_is_row_dirty, .{ .name = "ghostty_render_state_is_row_dirty" });
+        @export(&c.render_state_mark_clean, .{ .name = "ghostty_render_state_mark_clean" });
+        @export(&c.render_state_get_viewport, .{ .name = "ghostty_render_state_get_viewport" });
+        @export(&c.render_state_get_grapheme, .{ .name = "ghostty_render_state_get_grapheme" });
+
+        // Terminal modes
+        @export(&c.terminal_is_alternate_screen, .{ .name = "ghostty_terminal_is_alternate_screen" });
+        @export(&c.terminal_has_mouse_tracking, .{ .name = "ghostty_terminal_has_mouse_tracking" });
+        @export(&c.terminal_get_mode, .{ .name = "ghostty_terminal_get_mode" });
+
+        // Scrollback API
+        @export(&c.terminal_get_scrollback_length, .{ .name = "ghostty_terminal_get_scrollback_length" });
+        @export(&c.terminal_get_scrollback_line, .{ .name = "ghostty_terminal_get_scrollback_line" });
+        @export(&c.terminal_get_scrollback_grapheme, .{ .name = "ghostty_terminal_get_scrollback_grapheme" });
+        @export(&c.terminal_is_row_wrapped, .{ .name = "ghostty_terminal_is_row_wrapped" });
+
+        // Response API (for DSR and other queries)
+        @export(&c.terminal_has_response, .{ .name = "ghostty_terminal_has_response" });
+        @export(&c.terminal_read_response, .{ .name = "ghostty_terminal_read_response" });
 
         // On Wasm we need to export our allocator convenience functions.
         if (builtin.target.cpu.arch.isWasm()) {
diff --git a/src/quirks.zig b/src/quirks.zig
index 8e639bbf0..fbb5389dc 100644
--- a/src/quirks.zig
+++ b/src/quirks.zig
@@ -8,7 +8,10 @@
 const std = @import("std");
 const builtin = @import("builtin");
 
-const font = @import("font/main.zig");
+const font = if (builtin.target.cpu.arch.isWasm())
+    struct { pub const Face = opaque {}; }
+else
+    @import("font/main.zig");
 
 /// If true, the default font features should be disabled for the given face.
 pub fn disableDefaultFontFeatures(face: *const font.Face) bool {
diff --git a/src/terminal/c/main.zig b/src/terminal/c/main.zig
index bc92597f5..9de845c5d 100644
--- a/src/terminal/c/main.zig
+++ b/src/terminal/c/main.zig
@@ -4,6 +4,7 @@ pub const key_event = @import("key_event.zig");
 pub const key_encode = @import("key_encode.zig");
 pub const paste = @import("paste.zig");
 pub const sgr = @import("sgr.zig");
+pub const terminal = @import("terminal.zig");
 
 // The full C API, unexported.
 pub const osc_new = osc.new;
@@ -52,6 +53,43 @@ pub const key_encoder_encode = key_encode.encode;
 
 pub const paste_is_safe = paste.is_safe;
 
+// Terminal lifecycle
+pub const terminal_new = terminal.new;
+pub const terminal_new_with_config = terminal.newWithConfig;
+pub const terminal_free = terminal.free;
+pub const terminal_resize = terminal.resize;
+pub const terminal_write = terminal.write;
+
+// RenderState API - high-performance rendering
+pub const render_state_update = terminal.renderStateUpdate;
+pub const render_state_get_dirty_reasons = terminal.renderStateGetDirtyReasons;
+pub const render_state_get_cols = terminal.renderStateGetCols;
+pub const render_state_get_rows = terminal.renderStateGetRows;
+pub const render_state_get_cursor_x = terminal.renderStateGetCursorX;
+pub const render_state_get_cursor_y = terminal.renderStateGetCursorY;
+pub const render_state_get_cursor_visible = terminal.renderStateGetCursorVisible;
+pub const render_state_get_bg_color = terminal.renderStateGetBgColor;
+pub const render_state_get_fg_color = terminal.renderStateGetFgColor;
+pub const render_state_is_row_dirty = terminal.renderStateIsRowDirty;
+pub const render_state_mark_clean = terminal.renderStateMarkClean;
+pub const render_state_get_viewport = terminal.renderStateGetViewport;
+pub const render_state_get_grapheme = terminal.renderStateGetGrapheme;
+
+// Terminal modes
+pub const terminal_is_alternate_screen = terminal.isAlternateScreen;
+pub const terminal_has_mouse_tracking = terminal.hasMouseTracking;
+pub const terminal_get_mode = terminal.getMode;
+
+// Scrollback API
+pub const terminal_get_scrollback_length = terminal.getScrollbackLength;
+pub const terminal_get_scrollback_line = terminal.getScrollbackLine;
+pub const terminal_get_scrollback_grapheme = terminal.getScrollbackGrapheme;
+pub const terminal_is_row_wrapped = terminal.isRowWrapped;
+
+// Response API (for DSR and other queries)
+pub const terminal_has_response = terminal.hasResponse;
+pub const terminal_read_response = terminal.readResponse;
+
 test {
     _ = color;
     _ = osc;
@@ -59,6 +97,7 @@ test {
     _ = key_encode;
     _ = paste;
     _ = sgr;
+    _ = terminal;
 
     // We want to make sure we run the tests for the C allocator interface.
     _ = @import("../../lib/allocator.zig");
diff --git a/src/terminal/c/terminal.zig b/src/terminal/c/terminal.zig
new file mode 100644
index 000000000..c05bc09cc
--- /dev/null
+++ b/src/terminal/c/terminal.zig
@@ -0,0 +1,587 @@
+const std = @import("std");
+const Allocator = std.mem.Allocator;
+const lib_alloc = @import("../../lib/allocator.zig");
+const CAllocator = lib_alloc.Allocator;
+const color = @import("../color.zig");
+const modes = @import("../modes.zig");
+const page = @import("../page.zig");
+const point = @import("../point.zig");
+const render = @import("../render.zig");
+const size = @import("../size.zig");
+const stylepkg = @import("../style.zig");
+const terminalpkg = @import("../Terminal.zig");
+const stream_readonly = @import("../stream_readonly.zig");
+
+const log = std.log.scoped(.terminal);
+
+const Terminal = terminalpkg;
+const ReadonlyStream = stream_readonly.Stream;
+const RenderState = render.RenderState;
+
+const DirtyReason = struct {
+    const screen_switch: u32 = 1 << 0;
+    const terminal_palette: u32 = 1 << 1;
+    const terminal_reverse: u32 = 1 << 2;
+    const terminal_clear: u32 = 1 << 3;
+    const terminal_preedit: u32 = 1 << 4;
+    const screen_selection: u32 = 1 << 5;
+    const screen_hyperlink: u32 = 1 << 6;
+    const size_changed: u32 = 1 << 7;
+    const viewport_pin: u32 = 1 << 8;
+};
+
+const TerminalWrapper = struct {
+    terminal: Terminal,
+    render_state: RenderState = RenderState.empty,
+    stream: ReadonlyStream,
+    alloc: Allocator,
+    last_dirty_reasons: u32 = 0,
+};
+
+/// C: GhosttyTerminal
+pub const TerminalHandle = ?*TerminalWrapper;
+
+const TerminalConfig = extern struct {
+    scrollback_limit: u32,
+    fg_color: u32,
+    bg_color: u32,
+    cursor_color: u32,
+    palette: [16]u32,
+};
+
+const CellOut = extern struct {
+    codepoint: u32,
+    fg_r: u8,
+    fg_g: u8,
+    fg_b: u8,
+    bg_r: u8,
+    bg_g: u8,
+    bg_b: u8,
+    flags: u8,
+    width: u8,
+    hyperlink_id: u16,
+    grapheme_len: u8,
+    _padding: u8 = 0,
+};
+
+comptime {
+    std.debug.assert(@sizeOf(CellOut) == 16);
+}
+
+pub fn new(cols: u16, rows: u16) callconv(.c) TerminalHandle {
+    return initTerminal(cols, rows, null);
+}
+
+pub fn newWithConfig(
+    cols: u16,
+    rows: u16,
+    config_ptr: ?*const TerminalConfig,
+) callconv(.c) TerminalHandle {
+    return initTerminal(cols, rows, config_ptr);
+}
+
+pub fn free(handle: TerminalHandle) callconv(.c) void {
+    const wrapper = handle orelse return;
+    const alloc = wrapper.alloc;
+    wrapper.stream.deinit();
+    wrapper.render_state.deinit(alloc);
+    wrapper.terminal.deinit(alloc);
+    alloc.destroy(wrapper);
+}
+
+pub fn resize(handle: TerminalHandle, cols: u16, rows: u16) callconv(.c) void {
+    const wrapper = handle orelse return;
+    wrapper.terminal.resize(wrapper.alloc, cols, rows) catch |err| {
+        log.err("resize failed: {}", .{err});
+    };
+}
+
+pub fn write(handle: TerminalHandle, input: [*]const u8, len: usize) callconv(.c) void {
+    const wrapper = handle orelse return;
+    if (len == 0) return;
+    wrapper.stream.nextSlice(input[0..len]) catch |err| {
+        log.err("write failed: {}", .{err});
+    };
+}
+
+pub fn renderStateUpdate(handle: TerminalHandle) callconv(.c) u32 {
+    const wrapper = handle orelse return 0;
+    wrapper.last_dirty_reasons = computeDirtyReasons(wrapper);
+    wrapper.render_state.update(wrapper.alloc, &wrapper.terminal) catch |err| {
+        log.err("render state update failed: {}", .{err});
+        return 0;
+    };
+    return switch (wrapper.render_state.dirty) {
+        .false => 0,
+        .partial => 1,
+        .full => 2,
+    };
+}
+
+pub fn renderStateGetDirtyReasons(handle: TerminalHandle) callconv(.c) u32 {
+    const wrapper = handle orelse return 0;
+    return wrapper.last_dirty_reasons;
+}
+
+pub fn renderStateGetCols(handle: TerminalHandle) callconv(.c) u16 {
+    const wrapper = handle orelse return 0;
+    return wrapper.render_state.cols;
+}
+
+pub fn renderStateGetRows(handle: TerminalHandle) callconv(.c) u16 {
+    const wrapper = handle orelse return 0;
+    return wrapper.render_state.rows;
+}
+
+pub fn renderStateGetCursorX(handle: TerminalHandle) callconv(.c) u16 {
+    const wrapper = handle orelse return 0;
+    if (wrapper.render_state.cursor.viewport) |vp| return vp.x;
+    return 0;
+}
+
+pub fn renderStateGetCursorY(handle: TerminalHandle) callconv(.c) u16 {
+    const wrapper = handle orelse return 0;
+    if (wrapper.render_state.cursor.viewport) |vp| return vp.y;
+    return 0;
+}
+
+pub fn renderStateGetCursorVisible(handle: TerminalHandle) callconv(.c) bool {
+    const wrapper = handle orelse return false;
+    if (wrapper.render_state.cursor.viewport == null) return false;
+    return wrapper.render_state.cursor.visible;
+}
+
+pub fn renderStateGetBgColor(handle: TerminalHandle) callconv(.c) u32 {
+    const wrapper = handle orelse return 0;
+    return packRgb(wrapper.render_state.colors.background);
+}
+
+pub fn renderStateGetFgColor(handle: TerminalHandle) callconv(.c) u32 {
+    const wrapper = handle orelse return 0;
+    return packRgb(wrapper.render_state.colors.foreground);
+}
+
+pub fn renderStateIsRowDirty(handle: TerminalHandle, row: u16) callconv(.c) bool {
+    const wrapper = handle orelse return false;
+    const rows_len: usize = std.math.cast(usize, wrapper.render_state.rows) orelse return false;
+    const idx: usize = std.math.cast(usize, row) orelse return false;
+    if (idx >= rows_len) return false;
+    return wrapper.render_state.row_data.items(.dirty)[idx];
+}
+
+pub fn renderStateMarkClean(handle: TerminalHandle) callconv(.c) void {
+    const wrapper = handle orelse return;
+    wrapper.render_state.dirty = .false;
+    const row_dirties = wrapper.render_state.row_data.items(.dirty);
+    for (row_dirties) |*dirty| dirty.* = false;
+}
+
+pub fn renderStateGetViewport(
+    handle: TerminalHandle,
+    out_ptr: [*]CellOut,
+    max_cells: usize,
+) callconv(.c) isize {
+    const wrapper = handle orelse return -1;
+    const rows = wrapper.render_state.rows;
+    const cols = wrapper.render_state.cols;
+    const rows_len: usize = std.math.cast(usize, rows) orelse return -1;
+    const cols_len: usize = std.math.cast(usize, cols) orelse return -1;
+    if (rows_len == 0 or cols_len == 0) return 0;
+
+    const total = rows_len * cols_len;
+    if (max_cells < total) return -1;
+
+    const row_data = wrapper.render_state.row_data.slice();
+    const row_pins = row_data.items(.pin);
+
+    const palette = &wrapper.render_state.colors.palette;
+    const default_fg = wrapper.render_state.colors.foreground;
+    const default_bg = wrapper.render_state.colors.background;
+
+    var y: usize = 0;
+    while (y < rows_len) : (y += 1) {
+        const row_pin = row_pins[y];
+        const page_ptr = &row_pin.node.data;
+        const row_ptr = row_pin.rowAndCell().row;
+        const page_cells = page_ptr.getCells(row_ptr);
+
+        var x: usize = 0;
+        while (x < cols_len) : (x += 1) {
+            const cell = &page_cells[x];
+            const style = if (cell.style_id > 0)
+                page_ptr.styles.get(page_ptr.memory, cell.style_id).*
+            else
+                stylepkg.Style{};
+
+            const fg = style.fg(.{ .default = default_fg, .palette = palette });
+            const bg = style.bg(cell, palette) orelse default_bg;
+            const flags = styleFlags(style);
+            const width = cellWidth(cell.*);
+            const hyperlink_id = hyperlinkId(page_ptr, cell);
+            const grapheme_len = graphemeLen(page_ptr, cell);
+
+            const idx = y * cols_len + x;
+            out_ptr[idx] = .{
+                .codepoint = cell.codepoint(),
+                .fg_r = fg.r,
+                .fg_g = fg.g,
+                .fg_b = fg.b,
+                .bg_r = bg.r,
+                .bg_g = bg.g,
+                .bg_b = bg.b,
+                .flags = flags,
+                .width = width,
+                .hyperlink_id = hyperlink_id,
+                .grapheme_len = grapheme_len,
+                ._padding = 0,
+            };
+        }
+    }
+
+    return @intCast(total);
+}
+
+pub fn renderStateGetGrapheme(
+    handle: TerminalHandle,
+    row: u16,
+    col: u16,
+    out_ptr: [*]u32,
+    max_len: usize,
+) callconv(.c) isize {
+    const wrapper = handle orelse return -1;
+    if (max_len == 0) return -1;
+
+    const rows_len: usize = std.math.cast(usize, wrapper.render_state.rows) orelse return -1;
+    const cols_len: usize = std.math.cast(usize, wrapper.render_state.cols) orelse return -1;
+    const row_idx: usize = std.math.cast(usize, row) orelse return -1;
+    const col_idx: usize = std.math.cast(usize, col) orelse return -1;
+    if (row_idx >= rows_len or col_idx >= cols_len) return -1;
+
+    const row_data = wrapper.render_state.row_data.slice();
+    const row_pin = row_data.items(.pin)[row_idx];
+    const page_ptr = &row_pin.node.data;
+    const row_ptr = row_pin.rowAndCell().row;
+    const page_cells = page_ptr.getCells(row_ptr);
+    const cell = &page_cells[col_idx];
+
+    var count: usize = 0;
+    const cp = cell.codepoint();
+    if (cp != 0) {
+        out_ptr[0] = cp;
+        count = 1;
+    }
+
+    if (cell.content_tag == .codepoint_grapheme and count < max_len) {
+        const graphemes = page_ptr.lookupGrapheme(cell) orelse &.{};
+        const remaining = max_len - count;
+        const copy_len = @min(remaining, graphemes.len);
+        if (copy_len > 0) {
+            var i: usize = 0;
+            while (i < copy_len) : (i += 1) {
+                out_ptr[count + i] = @intCast(graphemes[i]);
+            }
+            count += copy_len;
+        }
+    }
+
+    return @intCast(count);
+}
+
+pub fn isAlternateScreen(handle: TerminalHandle) callconv(.c) bool {
+    const wrapper = handle orelse return false;
+    return wrapper.terminal.screens.active_key == .alternate;
+}
+
+pub fn hasMouseTracking(handle: TerminalHandle) callconv(.c) bool {
+    const wrapper = handle orelse return false;
+    return wrapper.terminal.flags.mouse_event != terminalpkg.MouseEvents.none;
+}
+
+pub fn getMode(
+    handle: TerminalHandle,
+    mode_value: u16,
+    is_ansi: bool,
+) callconv(.c) bool {
+    const wrapper = handle orelse return false;
+    const mode = modes.modeFromInt(mode_value, is_ansi) orelse return false;
+    return wrapper.terminal.modes.get(mode);
+}
+
+pub fn getScrollbackLength(handle: TerminalHandle) callconv(.c) u32 {
+    const wrapper = handle orelse return 0;
+    const pages = &wrapper.terminal.screens.active.pages;
+    const total: usize = pages.total_rows;
+    const active: usize = std.math.cast(usize, pages.rows) orelse return 0;
+    if (total <= active) return 0;
+    return @intCast(total - active);
+}
+
+pub fn getScrollbackLine(
+    handle: TerminalHandle,
+    offset: u32,
+    out_ptr: [*]CellOut,
+    cols: u16,
+) callconv(.c) isize {
+    const wrapper = handle orelse return -1;
+    const pages = &wrapper.terminal.screens.active.pages;
+    const scrollback_len = getScrollbackLength(handle);
+    if (offset >= scrollback_len) return -1;
+
+    const cols_len: usize = std.math.cast(usize, cols) orelse return -1;
+    if (cols_len == 0) return 0;
+
+    const pin = pages.pin(.{ .history = .{ .x = 0, .y = offset } }) orelse return -1;
+    const page_ptr = &pin.node.data;
+    const row_ptr = pin.rowAndCell().row;
+    const page_cells = page_ptr.getCells(row_ptr);
+
+    const palette = &wrapper.render_state.colors.palette;
+    const default_fg = wrapper.render_state.colors.foreground;
+    const default_bg = wrapper.render_state.colors.background;
+
+    const limit = @min(cols_len, page_cells.len);
+    var x: usize = 0;
+    while (x < limit) : (x += 1) {
+        const cell = &page_cells[x];
+        const style = if (cell.style_id > 0)
+            page_ptr.styles.get(page_ptr.memory, cell.style_id).*
+        else
+            stylepkg.Style{};
+
+        const fg = style.fg(.{ .default = default_fg, .palette = palette });
+        const bg = style.bg(cell, palette) orelse default_bg;
+        const flags = styleFlags(style);
+        const width = cellWidth(cell.*);
+        const hyperlink_id = hyperlinkId(page_ptr, cell);
+        const grapheme_len = graphemeLen(page_ptr, cell);
+
+        out_ptr[x] = .{
+            .codepoint = cell.codepoint(),
+            .fg_r = fg.r,
+            .fg_g = fg.g,
+            .fg_b = fg.b,
+            .bg_r = bg.r,
+            .bg_g = bg.g,
+            .bg_b = bg.b,
+            .flags = flags,
+            .width = width,
+            .hyperlink_id = hyperlink_id,
+            .grapheme_len = grapheme_len,
+            ._padding = 0,
+        };
+    }
+
+    return @intCast(limit);
+}
+
+pub fn getScrollbackGrapheme(
+    handle: TerminalHandle,
+    offset: u32,
+    col: u16,
+    out_ptr: [*]u32,
+    max_len: usize,
+) callconv(.c) isize {
+    const wrapper = handle orelse return -1;
+    if (max_len == 0) return -1;
+    const pages = &wrapper.terminal.screens.active.pages;
+    const scrollback_len = getScrollbackLength(handle);
+    if (offset >= scrollback_len) return -1;
+
+    const pin = pages.pin(.{ .history = .{ .x = 0, .y = offset } }) orelse return -1;
+    const page_ptr = &pin.node.data;
+    const row_ptr = pin.rowAndCell().row;
+    const page_cells = page_ptr.getCells(row_ptr);
+    const col_idx: usize = std.math.cast(usize, col) orelse return -1;
+    if (col_idx >= page_cells.len) return -1;
+
+    const cell = &page_cells[col_idx];
+    var count: usize = 0;
+    const cp = cell.codepoint();
+    if (cp != 0) {
+        out_ptr[0] = cp;
+        count = 1;
+    }
+
+    if (cell.content_tag == .codepoint_grapheme and count < max_len) {
+        const graphemes = page_ptr.lookupGrapheme(cell) orelse &.{};
+        const remaining = max_len - count;
+        const copy_len = @min(remaining, graphemes.len);
+        if (copy_len > 0) {
+            var i: usize = 0;
+            while (i < copy_len) : (i += 1) {
+                out_ptr[count + i] = @intCast(graphemes[i]);
+            }
+            count += copy_len;
+        }
+    }
+
+    return @intCast(count);
+}
+
+pub fn isRowWrapped(handle: TerminalHandle, row: u16) callconv(.c) bool {
+    const wrapper = handle orelse return false;
+    const pages = &wrapper.terminal.screens.active.pages;
+    const row_idx: u32 = row;
+    const pin = pages.pin(.{ .active = .{ .x = 0, .y = row_idx } }) orelse return false;
+    const row_ptr = pin.rowAndCell().row;
+    return row_ptr.wrap;
+}
+
+pub fn hasResponse(_: TerminalHandle) callconv(.c) bool {
+    return false;
+}
+
+pub fn readResponse(
+    _: TerminalHandle,
+    _: [*]u8,
+    _: usize,
+) callconv(.c) isize {
+    return 0;
+}
+
+fn initTerminal(
+    cols: u16,
+    rows: u16,
+    config_ptr: ?*const TerminalConfig,
+) TerminalHandle {
+    const alloc = lib_alloc.default(null);
+    const options = buildOptions(cols, rows, config_ptr);
+    const term = Terminal.init(alloc, options) catch |err| {
+        log.err("terminal init failed: {}", .{err});
+        return null;
+    };
+
+    const wrapper = alloc.create(TerminalWrapper) catch |err| {
+        log.err("terminal alloc failed: {}", .{err});
+        var tmp = term;
+        tmp.deinit(alloc);
+        return null;
+    };
+
+    wrapper.* = .{
+        .terminal = term,
+        .stream = undefined,
+        .alloc = alloc,
+    };
+    wrapper.stream = wrapper.terminal.vtStream();
+    return wrapper;
+}
+
+fn buildOptions(
+    cols: u16,
+    rows: u16,
+    config_ptr: ?*const TerminalConfig,
+) terminalpkg.Options {
+    const cols_val: size.CellCountInt = cols;
+    const rows_val: size.CellCountInt = rows;
+    if (config_ptr == null) {
+        return .{ .cols = cols_val, .rows = rows_val };
+    }
+
+    const config = config_ptr.?;
+    var colors = terminalpkg.Colors.default;
+    if (maybeRgb(config.fg_color)) |fg| colors.foreground = color.DynamicRGB.init(fg);
+    if (maybeRgb(config.bg_color)) |bg| colors.background = color.DynamicRGB.init(bg);
+    if (maybeRgb(config.cursor_color)) |cursor| colors.cursor = color.DynamicRGB.init(cursor);
+
+    const palette = buildPalette(config);
+    colors.palette = color.DynamicPalette.init(palette);
+
+    return .{
+        .cols = cols_val,
+        .rows = rows_val,
+        .max_scrollback = config.scrollback_limit,
+        .colors = colors,
+    };
+}
+
+fn buildPalette(config: *const TerminalConfig) color.Palette {
+    var palette = color.default;
+    for (config.palette, 0..) |value, idx| {
+        if (value == 0) continue;
+        palette[idx] = rgbFromU32(value);
+    }
+    return palette;
+}
+
+fn rgbFromU32(value: u32) color.RGB {
+    return .{
+        .r = @intCast((value >> 16) & 0xff),
+        .g = @intCast((value >> 8) & 0xff),
+        .b = @intCast(value & 0xff),
+    };
+}
+
+fn maybeRgb(value: u32) ?color.RGB {
+    if (value == 0) return null;
+    return rgbFromU32(value);
+}
+
+fn packRgb(rgb: color.RGB) u32 {
+    return (@as(u32, rgb.r) << 16) | (@as(u32, rgb.g) << 8) | @as(u32, rgb.b);
+}
+
+fn styleFlags(style: stylepkg.Style) u8 {
+    var flags: u8 = 0;
+    if (style.flags.bold) flags |= 1 << 0;
+    if (style.flags.italic) flags |= 1 << 1;
+    if (style.flags.underline != .none) flags |= 1 << 2;
+    if (style.flags.strikethrough) flags |= 1 << 3;
+    if (style.flags.inverse) flags |= 1 << 4;
+    if (style.flags.invisible) flags |= 1 << 5;
+    if (style.flags.blink) flags |= 1 << 6;
+    if (style.flags.faint) flags |= 1 << 7;
+    return flags;
+}
+
+fn cellWidth(cell: page.Cell) u8 {
+    return switch (cell.wide) {
+        .wide => 2,
+        .spacer_head, .spacer_tail => 0,
+        .narrow => 1,
+    };
+}
+
+fn hyperlinkId(page_ptr: *page.Page, cell: *const page.Cell) u16 {
+    if (!cell.hyperlink) return 0;
+    const id = page_ptr.lookupHyperlink(cell) orelse return 0;
+    return std.math.cast(u16, id) orelse 0;
+}
+
+fn graphemeLen(page_ptr: *page.Page, cell: *const page.Cell) u8 {
+    if (cell.content_tag != .codepoint_grapheme) return 0;
+    const graphemes = page_ptr.lookupGrapheme(cell) orelse &.{};
+    return std.math.cast(u8, graphemes.len) orelse 0;
+}
+
+fn computeDirtyReasons(wrapper: *TerminalWrapper) u32 {
+    const t = &wrapper.terminal;
+    const s = t.screens.active;
+    const viewport_pin = s.pages.getTopLeft(.viewport);
+    var reasons: u32 = 0;
+
+    if (t.screens.active_key != wrapper.render_state.screen) {
+        reasons |= DirtyReason.screen_switch;
+    }
+    if (t.flags.dirty.palette) reasons |= DirtyReason.terminal_palette;
+    if (t.flags.dirty.reverse_colors) reasons |= DirtyReason.terminal_reverse;
+    if (t.flags.dirty.clear) reasons |= DirtyReason.terminal_clear;
+    if (t.flags.dirty.preedit) reasons |= DirtyReason.terminal_preedit;
+
+    if (s.dirty.selection) reasons |= DirtyReason.screen_selection;
+    if (s.dirty.hyperlink_hover) reasons |= DirtyReason.screen_hyperlink;
+
+    if (wrapper.render_state.rows != s.pages.rows or
+        wrapper.render_state.cols != s.pages.cols)
+    {
+        reasons |= DirtyReason.size_changed;
+    }
+
+    if (wrapper.render_state.viewport_pin) |old| {
+        if (!old.eql(viewport_pin)) reasons |= DirtyReason.viewport_pin;
+    } else {
+        reasons |= DirtyReason.viewport_pin;
+    }
+
+    return reasons;
+}
diff --git a/src/terminal/render.zig b/src/terminal/render.zig
index b6430ea34..d9f35d095 100644
--- a/src/terminal/render.zig
+++ b/src/terminal/render.zig
@@ -266,6 +266,11 @@ pub const RenderState = struct {
     ) Allocator.Error!void {
         const s: *Screen = t.screens.active;
         const viewport_pin = s.pages.getTopLeft(.viewport);
+        const max_rows: usize = std.math.cast(usize, self.rows) orelse 0;
+        const viewport_delta_rows: ?isize = if (self.viewport_pin) |old|
+            viewportDeltaRows(old, viewport_pin, max_rows)
+        else
+            null;
         const redraw = redraw: {
             // If our screen key changed, we need to do a full rebuild
             // because our render state is viewport-specific.
@@ -296,7 +301,9 @@ pub const RenderState = struct {
 
             // If our viewport pin changed, we do a full rebuild.
             if (self.viewport_pin) |old| {
-                if (!old.eql(viewport_pin)) break :redraw true;
+                if (!old.eql(viewport_pin)) {
+                    if (viewport_delta_rows == null) break :redraw true;
+                }
             }
 
             break :redraw false;
@@ -322,13 +329,14 @@ pub const RenderState = struct {
         // Colors.
         self.colors.cursor = t.colors.cursor.get();
         self.colors.palette = t.colors.palette.current;
-        bg_fg: {
+        {
             // Background/foreground can be unset initially which would
-            // depend on "default" background/foreground. The expected use
-            // case of Terminal is that the caller set their own configured
-            // defaults on load so this doesn't happen.
-            const bg = t.colors.background.get() orelse break :bg_fg;
-            const fg = t.colors.foreground.get() orelse break :bg_fg;
+            // depend on "default" background/foreground. Use sensible defaults
+            // (black background, light gray foreground) when not explicitly set.
+            const default_bg: color.RGB = .{ .r = 0, .g = 0, .b = 0 };
+            const default_fg: color.RGB = .{ .r = 204, .g = 204, .b = 204 };
+            const bg = t.colors.background.get() orelse default_bg;
+            const fg = t.colors.foreground.get() orelse default_fg;
             if (t.modes.get(.reverse_colors)) {
                 self.colors.background = fg;
                 self.colors.foreground = bg;
@@ -378,6 +386,25 @@ pub const RenderState = struct {
             }
         }
 
+        var scroll_dirty_range: ?struct { start: usize, end: usize } = null;
+        if (!redraw) {
+            if (viewport_delta_rows) |delta| {
+                if (delta != 0 and max_rows > 0) {
+                    const abs_delta: usize = if (delta < 0)
+                        @intCast(-delta)
+                    else
+                        @intCast(delta);
+                    if (abs_delta > 0 and abs_delta < max_rows) {
+                        self.scrollRowData(alloc, delta);
+                        scroll_dirty_range = if (delta > 0)
+                            .{ .start = max_rows - abs_delta, .end = max_rows }
+                        else
+                            .{ .start = 0, .end = abs_delta };
+                    }
+                }
+            }
+        }
+
         // Break down our row data
         const row_data = self.row_data.slice();
         const row_arenas = row_data.items(.arena);
@@ -431,6 +458,10 @@ pub const RenderState = struct {
             const page_rac = row_pin.rowAndCell();
 
             dirty: {
+                if (scroll_dirty_range) |range| {
+                    if (y >= range.start and y < range.end) break :dirty;
+                }
+
                 // If we're redrawing then we're definitely dirty.
                 if (redraw) break :dirty;
 
@@ -647,6 +678,201 @@ pub const RenderState = struct {
         s.dirty = .{};
     }
 
+    fn viewportDeltaRows(
+        old: PageList.Pin,
+        new: PageList.Pin,
+        max_rows: usize,
+    ) ?isize {
+        if (max_rows == 0) return null;
+        if (old.eql(new)) return 0;
+        if (old.node == new.node) {
+            const old_y: isize = @intCast(old.y);
+            const new_y: isize = @intCast(new.y);
+            const delta = new_y - old_y;
+            const abs_delta: usize = if (delta < 0)
+                @intCast(-delta)
+            else
+                @intCast(delta);
+            if (abs_delta >= max_rows) return null;
+            return delta;
+        }
+
+        var pin_cursor = old;
+        var step: usize = 0;
+        while (step < max_rows) : (step += 1) {
+            if (pin_cursor.eql(new)) return @intCast(step);
+            pin_cursor = pin_cursor.down(1) orelse break;
+        }
+
+        pin_cursor = old;
+        step = 0;
+        while (step < max_rows) : (step += 1) {
+            if (pin_cursor.eql(new)) return -@as(isize, @intCast(step));
+            pin_cursor = pin_cursor.up(1) orelse break;
+        }
+
+        return null;
+    }
+
+    fn scrollRowData(self: *RenderState, alloc: Allocator, delta: isize) void {
+        const rows_len: usize = std.math.cast(usize, self.rows) orelse return;
+        if (rows_len == 0) return;
+
+        const shift: usize = if (delta < 0)
+            @intCast(-delta)
+        else
+            @intCast(delta);
+        if (shift == 0 or shift >= rows_len) return;
+
+        const row_data = self.row_data.slice();
+        const row_arenas = row_data.items(.arena);
+        const row_pins = row_data.items(.pin);
+        const row_rows = row_data.items(.raw);
+        const row_cells = row_data.items(.cells);
+        const row_dirties = row_data.items(.dirty);
+        const row_sels = row_data.items(.selection);
+        const row_highlights = row_data.items(.highlights);
+
+        var step: usize = 0;
+        while (step < shift) : (step += 1) {
+            if (delta > 0) {
+                rotateLeft(
+                    row_arenas,
+                    row_pins,
+                    row_rows,
+                    row_cells,
+                    row_dirties,
+                    row_sels,
+                    row_highlights,
+                );
+            } else {
+                rotateRight(
+                    row_arenas,
+                    row_pins,
+                    row_rows,
+                    row_cells,
+                    row_dirties,
+                    row_sels,
+                    row_highlights,
+                );
+            }
+        }
+
+        const start: usize = if (delta > 0) rows_len - shift else 0;
+        const end: usize = if (delta > 0) rows_len else shift;
+        var i: usize = start;
+        while (i < end) : (i += 1) {
+            resetRow(
+                alloc,
+                row_arenas,
+                row_cells,
+                row_highlights,
+                row_sels,
+                row_dirties,
+                i,
+            );
+        }
+    }
+
+    fn rotateLeft(
+        row_arenas: []ArenaAllocator.State,
+        row_pins: []PageList.Pin,
+        row_rows: []page.Row,
+        row_cells: []std.MultiArrayList(Cell),
+        row_dirties: []bool,
+        row_sels: []?([2]size.CellCountInt),
+        row_highlights: []std.ArrayList(Highlight),
+    ) void {
+        const len = row_arenas.len;
+        if (len < 2) return;
+
+        const temp_arena = row_arenas[0];
+        const temp_pin = row_pins[0];
+        const temp_row = row_rows[0];
+        const temp_cells = row_cells[0];
+        const temp_dirty = row_dirties[0];
+        const temp_sel = row_sels[0];
+        const temp_highlights = row_highlights[0];
+
+        var i: usize = 0;
+        while (i + 1 < len) : (i += 1) {
+            row_arenas[i] = row_arenas[i + 1];
+            row_pins[i] = row_pins[i + 1];
+            row_rows[i] = row_rows[i + 1];
+            row_cells[i] = row_cells[i + 1];
+            row_dirties[i] = row_dirties[i + 1];
+            row_sels[i] = row_sels[i + 1];
+            row_highlights[i] = row_highlights[i + 1];
+        }
+
+        row_arenas[len - 1] = temp_arena;
+        row_pins[len - 1] = temp_pin;
+        row_rows[len - 1] = temp_row;
+        row_cells[len - 1] = temp_cells;
+        row_dirties[len - 1] = temp_dirty;
+        row_sels[len - 1] = temp_sel;
+        row_highlights[len - 1] = temp_highlights;
+    }
+
+    fn rotateRight(
+        row_arenas: []ArenaAllocator.State,
+        row_pins: []PageList.Pin,
+        row_rows: []page.Row,
+        row_cells: []std.MultiArrayList(Cell),
+        row_dirties: []bool,
+        row_sels: []?([2]size.CellCountInt),
+        row_highlights: []std.ArrayList(Highlight),
+    ) void {
+        const len = row_arenas.len;
+        if (len < 2) return;
+
+        const last = len - 1;
+        const temp_arena = row_arenas[last];
+        const temp_pin = row_pins[last];
+        const temp_row = row_rows[last];
+        const temp_cells = row_cells[last];
+        const temp_dirty = row_dirties[last];
+        const temp_sel = row_sels[last];
+        const temp_highlights = row_highlights[last];
+
+        var i: usize = last;
+        while (i > 0) : (i -= 1) {
+            row_arenas[i] = row_arenas[i - 1];
+            row_pins[i] = row_pins[i - 1];
+            row_rows[i] = row_rows[i - 1];
+            row_cells[i] = row_cells[i - 1];
+            row_dirties[i] = row_dirties[i - 1];
+            row_sels[i] = row_sels[i - 1];
+            row_highlights[i] = row_highlights[i - 1];
+        }
+
+        row_arenas[0] = temp_arena;
+        row_pins[0] = temp_pin;
+        row_rows[0] = temp_row;
+        row_cells[0] = temp_cells;
+        row_dirties[0] = temp_dirty;
+        row_sels[0] = temp_sel;
+        row_highlights[0] = temp_highlights;
+    }
+
+    fn resetRow(
+        alloc: Allocator,
+        row_arenas: []ArenaAllocator.State,
+        row_cells: []std.MultiArrayList(Cell),
+        row_highlights: []std.ArrayList(Highlight),
+        row_sels: []?([2]size.CellCountInt),
+        row_dirties: []bool,
+        idx: usize,
+    ) void {
+        var arena = row_arenas[idx].promote(alloc);
+        _ = arena.reset(.retain_capacity);
+        row_arenas[idx] = arena.state;
+        row_cells[idx].clearRetainingCapacity();
+        row_highlights[idx].clearRetainingCapacity();
+        row_sels[idx] = null;
+        row_dirties[idx] = true;
+    }
+
     /// Update the highlights in the render state from the given flattened
     /// highlights. Because this uses flattened highlights, it does not require
     /// reading from the terminal state so it should be done outside of
diff --git a/src/terminal/style.zig b/src/terminal/style.zig
index e5c47b9fe..1a4ecceb3 100644
--- a/src/terminal/style.zig
+++ b/src/terminal/style.zig
@@ -1,7 +1,24 @@
 const std = @import("std");
 const assert = @import("../quirks.zig").inlineAssert;
-const configpkg = @import("../config.zig");
+const build_options = @import("terminal_options");
 const color = @import("color.zig");
+const configpkg = if (build_options.artifact == .lib)
+    struct {
+        pub const BoldColorValue = struct {
+            rgb: color.RGB,
+
+            pub fn toTerminalRGB(self: BoldColorValue) color.RGB {
+                return self.rgb;
+            }
+        };
+
+        pub const BoldColor = union(enum) {
+            color: BoldColorValue,
+            bright,
+        };
+    }
+else
+    @import("../config.zig");
 const sgr = @import("sgr.zig");
 const page = @import("page.zig");
 const size = @import("size.zig");
